// Code generated by counterfeiter. DO NOT EDIT.
package batchv1fake

import (
	"context"
	"sync"

	"cloud.google.com/go/batch/apiv1/batchpb"
	"cloud.google.com/go/longrunning/autogen/longrunningpb"
	batchv1 "github.com/connect-sdk/batch-api/proto/connect/batch/v1"
	gax "github.com/googleapis/gax-go/v2"
)

type FakeBatchServiceClient struct {
	CancelOperationStub        func(context.Context, *longrunningpb.CancelOperationRequest, ...gax.CallOption) error
	cancelOperationMutex       sync.RWMutex
	cancelOperationArgsForCall []struct {
		arg1 context.Context
		arg2 *longrunningpb.CancelOperationRequest
		arg3 []gax.CallOption
	}
	cancelOperationReturns struct {
		result1 error
	}
	cancelOperationReturnsOnCall map[int]struct {
		result1 error
	}
	CreateJobStub        func(context.Context, *batchpb.CreateJobRequest, ...gax.CallOption) (*batchpb.Job, error)
	createJobMutex       sync.RWMutex
	createJobArgsForCall []struct {
		arg1 context.Context
		arg2 *batchpb.CreateJobRequest
		arg3 []gax.CallOption
	}
	createJobReturns struct {
		result1 *batchpb.Job
		result2 error
	}
	createJobReturnsOnCall map[int]struct {
		result1 *batchpb.Job
		result2 error
	}
	DeleteJobStub        func(context.Context, *batchpb.DeleteJobRequest, ...gax.CallOption) (batchv1.DeleteBatchJobOperation, error)
	deleteJobMutex       sync.RWMutex
	deleteJobArgsForCall []struct {
		arg1 context.Context
		arg2 *batchpb.DeleteJobRequest
		arg3 []gax.CallOption
	}
	deleteJobReturns struct {
		result1 batchv1.DeleteBatchJobOperation
		result2 error
	}
	deleteJobReturnsOnCall map[int]struct {
		result1 batchv1.DeleteBatchJobOperation
		result2 error
	}
	DeleteJobOperationStub        func(string) batchv1.DeleteBatchJobOperation
	deleteJobOperationMutex       sync.RWMutex
	deleteJobOperationArgsForCall []struct {
		arg1 string
	}
	deleteJobOperationReturns struct {
		result1 batchv1.DeleteBatchJobOperation
	}
	deleteJobOperationReturnsOnCall map[int]struct {
		result1 batchv1.DeleteBatchJobOperation
	}
	DeleteOperationStub        func(context.Context, *longrunningpb.DeleteOperationRequest, ...gax.CallOption) error
	deleteOperationMutex       sync.RWMutex
	deleteOperationArgsForCall []struct {
		arg1 context.Context
		arg2 *longrunningpb.DeleteOperationRequest
		arg3 []gax.CallOption
	}
	deleteOperationReturns struct {
		result1 error
	}
	deleteOperationReturnsOnCall map[int]struct {
		result1 error
	}
	GetJobStub        func(context.Context, *batchpb.GetJobRequest, ...gax.CallOption) (*batchpb.Job, error)
	getJobMutex       sync.RWMutex
	getJobArgsForCall []struct {
		arg1 context.Context
		arg2 *batchpb.GetJobRequest
		arg3 []gax.CallOption
	}
	getJobReturns struct {
		result1 *batchpb.Job
		result2 error
	}
	getJobReturnsOnCall map[int]struct {
		result1 *batchpb.Job
		result2 error
	}
	GetTaskStub        func(context.Context, *batchpb.GetTaskRequest, ...gax.CallOption) (*batchpb.Task, error)
	getTaskMutex       sync.RWMutex
	getTaskArgsForCall []struct {
		arg1 context.Context
		arg2 *batchpb.GetTaskRequest
		arg3 []gax.CallOption
	}
	getTaskReturns struct {
		result1 *batchpb.Task
		result2 error
	}
	getTaskReturnsOnCall map[int]struct {
		result1 *batchpb.Task
		result2 error
	}
	ListJobsStub        func(context.Context, *batchpb.ListJobsRequest, ...gax.CallOption) batchv1.BatchJobIterator
	listJobsMutex       sync.RWMutex
	listJobsArgsForCall []struct {
		arg1 context.Context
		arg2 *batchpb.ListJobsRequest
		arg3 []gax.CallOption
	}
	listJobsReturns struct {
		result1 batchv1.BatchJobIterator
	}
	listJobsReturnsOnCall map[int]struct {
		result1 batchv1.BatchJobIterator
	}
	ListTasksStub        func(context.Context, *batchpb.ListTasksRequest, ...gax.CallOption) batchv1.BatchTaskIterator
	listTasksMutex       sync.RWMutex
	listTasksArgsForCall []struct {
		arg1 context.Context
		arg2 *batchpb.ListTasksRequest
		arg3 []gax.CallOption
	}
	listTasksReturns struct {
		result1 batchv1.BatchTaskIterator
	}
	listTasksReturnsOnCall map[int]struct {
		result1 batchv1.BatchTaskIterator
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBatchServiceClient) CancelOperation(arg1 context.Context, arg2 *longrunningpb.CancelOperationRequest, arg3 ...gax.CallOption) error {
	fake.cancelOperationMutex.Lock()
	ret, specificReturn := fake.cancelOperationReturnsOnCall[len(fake.cancelOperationArgsForCall)]
	fake.cancelOperationArgsForCall = append(fake.cancelOperationArgsForCall, struct {
		arg1 context.Context
		arg2 *longrunningpb.CancelOperationRequest
		arg3 []gax.CallOption
	}{arg1, arg2, arg3})
	stub := fake.CancelOperationStub
	fakeReturns := fake.cancelOperationReturns
	fake.recordInvocation("CancelOperation", []interface{}{arg1, arg2, arg3})
	fake.cancelOperationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBatchServiceClient) CancelOperationCallCount() int {
	fake.cancelOperationMutex.RLock()
	defer fake.cancelOperationMutex.RUnlock()
	return len(fake.cancelOperationArgsForCall)
}

func (fake *FakeBatchServiceClient) CancelOperationCalls(stub func(context.Context, *longrunningpb.CancelOperationRequest, ...gax.CallOption) error) {
	fake.cancelOperationMutex.Lock()
	defer fake.cancelOperationMutex.Unlock()
	fake.CancelOperationStub = stub
}

func (fake *FakeBatchServiceClient) CancelOperationArgsForCall(i int) (context.Context, *longrunningpb.CancelOperationRequest, []gax.CallOption) {
	fake.cancelOperationMutex.RLock()
	defer fake.cancelOperationMutex.RUnlock()
	argsForCall := fake.cancelOperationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBatchServiceClient) CancelOperationReturns(result1 error) {
	fake.cancelOperationMutex.Lock()
	defer fake.cancelOperationMutex.Unlock()
	fake.CancelOperationStub = nil
	fake.cancelOperationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBatchServiceClient) CancelOperationReturnsOnCall(i int, result1 error) {
	fake.cancelOperationMutex.Lock()
	defer fake.cancelOperationMutex.Unlock()
	fake.CancelOperationStub = nil
	if fake.cancelOperationReturnsOnCall == nil {
		fake.cancelOperationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelOperationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBatchServiceClient) CreateJob(arg1 context.Context, arg2 *batchpb.CreateJobRequest, arg3 ...gax.CallOption) (*batchpb.Job, error) {
	fake.createJobMutex.Lock()
	ret, specificReturn := fake.createJobReturnsOnCall[len(fake.createJobArgsForCall)]
	fake.createJobArgsForCall = append(fake.createJobArgsForCall, struct {
		arg1 context.Context
		arg2 *batchpb.CreateJobRequest
		arg3 []gax.CallOption
	}{arg1, arg2, arg3})
	stub := fake.CreateJobStub
	fakeReturns := fake.createJobReturns
	fake.recordInvocation("CreateJob", []interface{}{arg1, arg2, arg3})
	fake.createJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBatchServiceClient) CreateJobCallCount() int {
	fake.createJobMutex.RLock()
	defer fake.createJobMutex.RUnlock()
	return len(fake.createJobArgsForCall)
}

func (fake *FakeBatchServiceClient) CreateJobCalls(stub func(context.Context, *batchpb.CreateJobRequest, ...gax.CallOption) (*batchpb.Job, error)) {
	fake.createJobMutex.Lock()
	defer fake.createJobMutex.Unlock()
	fake.CreateJobStub = stub
}

func (fake *FakeBatchServiceClient) CreateJobArgsForCall(i int) (context.Context, *batchpb.CreateJobRequest, []gax.CallOption) {
	fake.createJobMutex.RLock()
	defer fake.createJobMutex.RUnlock()
	argsForCall := fake.createJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBatchServiceClient) CreateJobReturns(result1 *batchpb.Job, result2 error) {
	fake.createJobMutex.Lock()
	defer fake.createJobMutex.Unlock()
	fake.CreateJobStub = nil
	fake.createJobReturns = struct {
		result1 *batchpb.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeBatchServiceClient) CreateJobReturnsOnCall(i int, result1 *batchpb.Job, result2 error) {
	fake.createJobMutex.Lock()
	defer fake.createJobMutex.Unlock()
	fake.CreateJobStub = nil
	if fake.createJobReturnsOnCall == nil {
		fake.createJobReturnsOnCall = make(map[int]struct {
			result1 *batchpb.Job
			result2 error
		})
	}
	fake.createJobReturnsOnCall[i] = struct {
		result1 *batchpb.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeBatchServiceClient) DeleteJob(arg1 context.Context, arg2 *batchpb.DeleteJobRequest, arg3 ...gax.CallOption) (batchv1.DeleteBatchJobOperation, error) {
	fake.deleteJobMutex.Lock()
	ret, specificReturn := fake.deleteJobReturnsOnCall[len(fake.deleteJobArgsForCall)]
	fake.deleteJobArgsForCall = append(fake.deleteJobArgsForCall, struct {
		arg1 context.Context
		arg2 *batchpb.DeleteJobRequest
		arg3 []gax.CallOption
	}{arg1, arg2, arg3})
	stub := fake.DeleteJobStub
	fakeReturns := fake.deleteJobReturns
	fake.recordInvocation("DeleteJob", []interface{}{arg1, arg2, arg3})
	fake.deleteJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBatchServiceClient) DeleteJobCallCount() int {
	fake.deleteJobMutex.RLock()
	defer fake.deleteJobMutex.RUnlock()
	return len(fake.deleteJobArgsForCall)
}

func (fake *FakeBatchServiceClient) DeleteJobCalls(stub func(context.Context, *batchpb.DeleteJobRequest, ...gax.CallOption) (batchv1.DeleteBatchJobOperation, error)) {
	fake.deleteJobMutex.Lock()
	defer fake.deleteJobMutex.Unlock()
	fake.DeleteJobStub = stub
}

func (fake *FakeBatchServiceClient) DeleteJobArgsForCall(i int) (context.Context, *batchpb.DeleteJobRequest, []gax.CallOption) {
	fake.deleteJobMutex.RLock()
	defer fake.deleteJobMutex.RUnlock()
	argsForCall := fake.deleteJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBatchServiceClient) DeleteJobReturns(result1 batchv1.DeleteBatchJobOperation, result2 error) {
	fake.deleteJobMutex.Lock()
	defer fake.deleteJobMutex.Unlock()
	fake.DeleteJobStub = nil
	fake.deleteJobReturns = struct {
		result1 batchv1.DeleteBatchJobOperation
		result2 error
	}{result1, result2}
}

func (fake *FakeBatchServiceClient) DeleteJobReturnsOnCall(i int, result1 batchv1.DeleteBatchJobOperation, result2 error) {
	fake.deleteJobMutex.Lock()
	defer fake.deleteJobMutex.Unlock()
	fake.DeleteJobStub = nil
	if fake.deleteJobReturnsOnCall == nil {
		fake.deleteJobReturnsOnCall = make(map[int]struct {
			result1 batchv1.DeleteBatchJobOperation
			result2 error
		})
	}
	fake.deleteJobReturnsOnCall[i] = struct {
		result1 batchv1.DeleteBatchJobOperation
		result2 error
	}{result1, result2}
}

func (fake *FakeBatchServiceClient) DeleteJobOperation(arg1 string) batchv1.DeleteBatchJobOperation {
	fake.deleteJobOperationMutex.Lock()
	ret, specificReturn := fake.deleteJobOperationReturnsOnCall[len(fake.deleteJobOperationArgsForCall)]
	fake.deleteJobOperationArgsForCall = append(fake.deleteJobOperationArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteJobOperationStub
	fakeReturns := fake.deleteJobOperationReturns
	fake.recordInvocation("DeleteJobOperation", []interface{}{arg1})
	fake.deleteJobOperationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBatchServiceClient) DeleteJobOperationCallCount() int {
	fake.deleteJobOperationMutex.RLock()
	defer fake.deleteJobOperationMutex.RUnlock()
	return len(fake.deleteJobOperationArgsForCall)
}

func (fake *FakeBatchServiceClient) DeleteJobOperationCalls(stub func(string) batchv1.DeleteBatchJobOperation) {
	fake.deleteJobOperationMutex.Lock()
	defer fake.deleteJobOperationMutex.Unlock()
	fake.DeleteJobOperationStub = stub
}

func (fake *FakeBatchServiceClient) DeleteJobOperationArgsForCall(i int) string {
	fake.deleteJobOperationMutex.RLock()
	defer fake.deleteJobOperationMutex.RUnlock()
	argsForCall := fake.deleteJobOperationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBatchServiceClient) DeleteJobOperationReturns(result1 batchv1.DeleteBatchJobOperation) {
	fake.deleteJobOperationMutex.Lock()
	defer fake.deleteJobOperationMutex.Unlock()
	fake.DeleteJobOperationStub = nil
	fake.deleteJobOperationReturns = struct {
		result1 batchv1.DeleteBatchJobOperation
	}{result1}
}

func (fake *FakeBatchServiceClient) DeleteJobOperationReturnsOnCall(i int, result1 batchv1.DeleteBatchJobOperation) {
	fake.deleteJobOperationMutex.Lock()
	defer fake.deleteJobOperationMutex.Unlock()
	fake.DeleteJobOperationStub = nil
	if fake.deleteJobOperationReturnsOnCall == nil {
		fake.deleteJobOperationReturnsOnCall = make(map[int]struct {
			result1 batchv1.DeleteBatchJobOperation
		})
	}
	fake.deleteJobOperationReturnsOnCall[i] = struct {
		result1 batchv1.DeleteBatchJobOperation
	}{result1}
}

func (fake *FakeBatchServiceClient) DeleteOperation(arg1 context.Context, arg2 *longrunningpb.DeleteOperationRequest, arg3 ...gax.CallOption) error {
	fake.deleteOperationMutex.Lock()
	ret, specificReturn := fake.deleteOperationReturnsOnCall[len(fake.deleteOperationArgsForCall)]
	fake.deleteOperationArgsForCall = append(fake.deleteOperationArgsForCall, struct {
		arg1 context.Context
		arg2 *longrunningpb.DeleteOperationRequest
		arg3 []gax.CallOption
	}{arg1, arg2, arg3})
	stub := fake.DeleteOperationStub
	fakeReturns := fake.deleteOperationReturns
	fake.recordInvocation("DeleteOperation", []interface{}{arg1, arg2, arg3})
	fake.deleteOperationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBatchServiceClient) DeleteOperationCallCount() int {
	fake.deleteOperationMutex.RLock()
	defer fake.deleteOperationMutex.RUnlock()
	return len(fake.deleteOperationArgsForCall)
}

func (fake *FakeBatchServiceClient) DeleteOperationCalls(stub func(context.Context, *longrunningpb.DeleteOperationRequest, ...gax.CallOption) error) {
	fake.deleteOperationMutex.Lock()
	defer fake.deleteOperationMutex.Unlock()
	fake.DeleteOperationStub = stub
}

func (fake *FakeBatchServiceClient) DeleteOperationArgsForCall(i int) (context.Context, *longrunningpb.DeleteOperationRequest, []gax.CallOption) {
	fake.deleteOperationMutex.RLock()
	defer fake.deleteOperationMutex.RUnlock()
	argsForCall := fake.deleteOperationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBatchServiceClient) DeleteOperationReturns(result1 error) {
	fake.deleteOperationMutex.Lock()
	defer fake.deleteOperationMutex.Unlock()
	fake.DeleteOperationStub = nil
	fake.deleteOperationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBatchServiceClient) DeleteOperationReturnsOnCall(i int, result1 error) {
	fake.deleteOperationMutex.Lock()
	defer fake.deleteOperationMutex.Unlock()
	fake.DeleteOperationStub = nil
	if fake.deleteOperationReturnsOnCall == nil {
		fake.deleteOperationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteOperationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBatchServiceClient) GetJob(arg1 context.Context, arg2 *batchpb.GetJobRequest, arg3 ...gax.CallOption) (*batchpb.Job, error) {
	fake.getJobMutex.Lock()
	ret, specificReturn := fake.getJobReturnsOnCall[len(fake.getJobArgsForCall)]
	fake.getJobArgsForCall = append(fake.getJobArgsForCall, struct {
		arg1 context.Context
		arg2 *batchpb.GetJobRequest
		arg3 []gax.CallOption
	}{arg1, arg2, arg3})
	stub := fake.GetJobStub
	fakeReturns := fake.getJobReturns
	fake.recordInvocation("GetJob", []interface{}{arg1, arg2, arg3})
	fake.getJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBatchServiceClient) GetJobCallCount() int {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	return len(fake.getJobArgsForCall)
}

func (fake *FakeBatchServiceClient) GetJobCalls(stub func(context.Context, *batchpb.GetJobRequest, ...gax.CallOption) (*batchpb.Job, error)) {
	fake.getJobMutex.Lock()
	defer fake.getJobMutex.Unlock()
	fake.GetJobStub = stub
}

func (fake *FakeBatchServiceClient) GetJobArgsForCall(i int) (context.Context, *batchpb.GetJobRequest, []gax.CallOption) {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	argsForCall := fake.getJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBatchServiceClient) GetJobReturns(result1 *batchpb.Job, result2 error) {
	fake.getJobMutex.Lock()
	defer fake.getJobMutex.Unlock()
	fake.GetJobStub = nil
	fake.getJobReturns = struct {
		result1 *batchpb.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeBatchServiceClient) GetJobReturnsOnCall(i int, result1 *batchpb.Job, result2 error) {
	fake.getJobMutex.Lock()
	defer fake.getJobMutex.Unlock()
	fake.GetJobStub = nil
	if fake.getJobReturnsOnCall == nil {
		fake.getJobReturnsOnCall = make(map[int]struct {
			result1 *batchpb.Job
			result2 error
		})
	}
	fake.getJobReturnsOnCall[i] = struct {
		result1 *batchpb.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeBatchServiceClient) GetTask(arg1 context.Context, arg2 *batchpb.GetTaskRequest, arg3 ...gax.CallOption) (*batchpb.Task, error) {
	fake.getTaskMutex.Lock()
	ret, specificReturn := fake.getTaskReturnsOnCall[len(fake.getTaskArgsForCall)]
	fake.getTaskArgsForCall = append(fake.getTaskArgsForCall, struct {
		arg1 context.Context
		arg2 *batchpb.GetTaskRequest
		arg3 []gax.CallOption
	}{arg1, arg2, arg3})
	stub := fake.GetTaskStub
	fakeReturns := fake.getTaskReturns
	fake.recordInvocation("GetTask", []interface{}{arg1, arg2, arg3})
	fake.getTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBatchServiceClient) GetTaskCallCount() int {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	return len(fake.getTaskArgsForCall)
}

func (fake *FakeBatchServiceClient) GetTaskCalls(stub func(context.Context, *batchpb.GetTaskRequest, ...gax.CallOption) (*batchpb.Task, error)) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = stub
}

func (fake *FakeBatchServiceClient) GetTaskArgsForCall(i int) (context.Context, *batchpb.GetTaskRequest, []gax.CallOption) {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	argsForCall := fake.getTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBatchServiceClient) GetTaskReturns(result1 *batchpb.Task, result2 error) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = nil
	fake.getTaskReturns = struct {
		result1 *batchpb.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeBatchServiceClient) GetTaskReturnsOnCall(i int, result1 *batchpb.Task, result2 error) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = nil
	if fake.getTaskReturnsOnCall == nil {
		fake.getTaskReturnsOnCall = make(map[int]struct {
			result1 *batchpb.Task
			result2 error
		})
	}
	fake.getTaskReturnsOnCall[i] = struct {
		result1 *batchpb.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeBatchServiceClient) ListJobs(arg1 context.Context, arg2 *batchpb.ListJobsRequest, arg3 ...gax.CallOption) batchv1.BatchJobIterator {
	fake.listJobsMutex.Lock()
	ret, specificReturn := fake.listJobsReturnsOnCall[len(fake.listJobsArgsForCall)]
	fake.listJobsArgsForCall = append(fake.listJobsArgsForCall, struct {
		arg1 context.Context
		arg2 *batchpb.ListJobsRequest
		arg3 []gax.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ListJobsStub
	fakeReturns := fake.listJobsReturns
	fake.recordInvocation("ListJobs", []interface{}{arg1, arg2, arg3})
	fake.listJobsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBatchServiceClient) ListJobsCallCount() int {
	fake.listJobsMutex.RLock()
	defer fake.listJobsMutex.RUnlock()
	return len(fake.listJobsArgsForCall)
}

func (fake *FakeBatchServiceClient) ListJobsCalls(stub func(context.Context, *batchpb.ListJobsRequest, ...gax.CallOption) batchv1.BatchJobIterator) {
	fake.listJobsMutex.Lock()
	defer fake.listJobsMutex.Unlock()
	fake.ListJobsStub = stub
}

func (fake *FakeBatchServiceClient) ListJobsArgsForCall(i int) (context.Context, *batchpb.ListJobsRequest, []gax.CallOption) {
	fake.listJobsMutex.RLock()
	defer fake.listJobsMutex.RUnlock()
	argsForCall := fake.listJobsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBatchServiceClient) ListJobsReturns(result1 batchv1.BatchJobIterator) {
	fake.listJobsMutex.Lock()
	defer fake.listJobsMutex.Unlock()
	fake.ListJobsStub = nil
	fake.listJobsReturns = struct {
		result1 batchv1.BatchJobIterator
	}{result1}
}

func (fake *FakeBatchServiceClient) ListJobsReturnsOnCall(i int, result1 batchv1.BatchJobIterator) {
	fake.listJobsMutex.Lock()
	defer fake.listJobsMutex.Unlock()
	fake.ListJobsStub = nil
	if fake.listJobsReturnsOnCall == nil {
		fake.listJobsReturnsOnCall = make(map[int]struct {
			result1 batchv1.BatchJobIterator
		})
	}
	fake.listJobsReturnsOnCall[i] = struct {
		result1 batchv1.BatchJobIterator
	}{result1}
}

func (fake *FakeBatchServiceClient) ListTasks(arg1 context.Context, arg2 *batchpb.ListTasksRequest, arg3 ...gax.CallOption) batchv1.BatchTaskIterator {
	fake.listTasksMutex.Lock()
	ret, specificReturn := fake.listTasksReturnsOnCall[len(fake.listTasksArgsForCall)]
	fake.listTasksArgsForCall = append(fake.listTasksArgsForCall, struct {
		arg1 context.Context
		arg2 *batchpb.ListTasksRequest
		arg3 []gax.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ListTasksStub
	fakeReturns := fake.listTasksReturns
	fake.recordInvocation("ListTasks", []interface{}{arg1, arg2, arg3})
	fake.listTasksMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBatchServiceClient) ListTasksCallCount() int {
	fake.listTasksMutex.RLock()
	defer fake.listTasksMutex.RUnlock()
	return len(fake.listTasksArgsForCall)
}

func (fake *FakeBatchServiceClient) ListTasksCalls(stub func(context.Context, *batchpb.ListTasksRequest, ...gax.CallOption) batchv1.BatchTaskIterator) {
	fake.listTasksMutex.Lock()
	defer fake.listTasksMutex.Unlock()
	fake.ListTasksStub = stub
}

func (fake *FakeBatchServiceClient) ListTasksArgsForCall(i int) (context.Context, *batchpb.ListTasksRequest, []gax.CallOption) {
	fake.listTasksMutex.RLock()
	defer fake.listTasksMutex.RUnlock()
	argsForCall := fake.listTasksArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBatchServiceClient) ListTasksReturns(result1 batchv1.BatchTaskIterator) {
	fake.listTasksMutex.Lock()
	defer fake.listTasksMutex.Unlock()
	fake.ListTasksStub = nil
	fake.listTasksReturns = struct {
		result1 batchv1.BatchTaskIterator
	}{result1}
}

func (fake *FakeBatchServiceClient) ListTasksReturnsOnCall(i int, result1 batchv1.BatchTaskIterator) {
	fake.listTasksMutex.Lock()
	defer fake.listTasksMutex.Unlock()
	fake.ListTasksStub = nil
	if fake.listTasksReturnsOnCall == nil {
		fake.listTasksReturnsOnCall = make(map[int]struct {
			result1 batchv1.BatchTaskIterator
		})
	}
	fake.listTasksReturnsOnCall[i] = struct {
		result1 batchv1.BatchTaskIterator
	}{result1}
}

func (fake *FakeBatchServiceClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelOperationMutex.RLock()
	defer fake.cancelOperationMutex.RUnlock()
	fake.createJobMutex.RLock()
	defer fake.createJobMutex.RUnlock()
	fake.deleteJobMutex.RLock()
	defer fake.deleteJobMutex.RUnlock()
	fake.deleteJobOperationMutex.RLock()
	defer fake.deleteJobOperationMutex.RUnlock()
	fake.deleteOperationMutex.RLock()
	defer fake.deleteOperationMutex.RUnlock()
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	fake.listJobsMutex.RLock()
	defer fake.listJobsMutex.RUnlock()
	fake.listTasksMutex.RLock()
	defer fake.listTasksMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBatchServiceClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ batchv1.BatchServiceClient = new(FakeBatchServiceClient)
